{"version":3,"sources":["../../../modules/effects/src/effects.ts","../../../modules/effects/src/bootstrap-listener.ts","../../../modules/effects/src/util.ts","../../../modules/effects/src/actions.ts","../../../modules/effects/src/singleton-effects.service.ts","../../../modules/effects/src/effects-subscription.ts","../../../modules/effects/src/effects.module.ts"],"names":["Effect","_a","dispatch","target","propertyName","hasOwnMetadata","METADATA_KEY","defineMetadata","effects","getOwnMetadata","metadata","concat","getEffectsMetadata","instance","Object","getPrototypeOf","mergeEffects","observables","map","observable","ignoreElements","call","merge","apply","runAfterBootstrapEffects","injector","subscription","effectInstances","get","afterBootstrapEffects","addEffects","toPayload","action","payload","Actions","_super","actionsSubject","_this","this","source","__extends","prototype","lift","operator","ofType","keys","_i","arguments","length","filter","type","len","i","Observable","decorators","Injectable","ctorParameters","Inject","args","ScannedActionsSubject","SingletonEffectsService","registeredEffects","removeExistingAndRegisterNew","instanceAsString","constructor","toString","indexOf","push","OpaqueToken","EffectsSubscription","store","singletonEffectsService","parent","add","sources","merged","subscribe","ngOnDestroy","closed","unsubscribe","Subscription","undefined","Store","Optional","SkipSelf","Array","EffectsModule","effectsSubscription","forRoot","ngModule","providers","run","provide","useExisting","multi","runAfterBootstrap","NgModule","APP_BOOTSTRAP_LISTENER","deps","Injector","useFactory"],"mappings":"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","file":"./dist/effects/bundles/effects.umd.min.js","sourcesContent":["import { merge } from 'rxjs/observable/merge';\nimport { ignoreElements } from 'rxjs/operator/ignoreElements';\nimport { Store } from '@ngrx/store';\nimport { Observable } from 'rxjs/Observable';\n\nconst /** @type {?} */ METADATA_KEY = '@ngrx/effects';\n\nexport interface EffectMetadata {\n  propertyName: string;\n  dispatch: boolean;\n}\n/**\n * @param {?=} __0\n * @return {?}\n */\nexport function Effect({ dispatch } = { dispatch: true }): PropertyDecorator {\n  return function(target: any, propertyName: string) {\n    if (!( /** @type {?} */((Reflect as any))).hasOwnMetadata(METADATA_KEY, target)) {\n      ( /** @type {?} */((Reflect as any))).defineMetadata(METADATA_KEY, [], target);\n    }\n\n    const /** @type {?} */ effects: EffectMetadata[] = ( /** @type {?} */((Reflect as any))).getOwnMetadata(METADATA_KEY, target);\n    const /** @type {?} */ metadata: EffectMetadata = { propertyName, dispatch };\n\n    ( /** @type {?} */((Reflect as any))).defineMetadata(METADATA_KEY, [ ...effects, metadata ], target);\n  };\n}\n/**\n * @param {?} instance\n * @return {?}\n */\nexport function getEffectsMetadata(instance: any): EffectMetadata[] {\n  const /** @type {?} */ target = Object.getPrototypeOf(instance);\n\n  if (!( /** @type {?} */((Reflect as any))).hasOwnMetadata(METADATA_KEY, target)) {\n    return [];\n  }\n\n  return ( /** @type {?} */((Reflect as any))).getOwnMetadata(METADATA_KEY, target);\n}\n/**\n * @param {?} instance\n * @return {?}\n */\nexport function mergeEffects(instance: any): Observable<any> {\n  const /** @type {?} */ observables: Observable<any>[] = getEffectsMetadata(instance).map(\n    ({ propertyName, dispatch }): Observable<any> => {\n      const /** @type {?} */ observable = typeof instance[propertyName] === 'function' ?\n        instance[propertyName]() : instance[propertyName];\n\n      if (dispatch === false) {\n        return ignoreElements.call(observable);\n      }\n\n      return observable;\n    }\n  );\n\n  return merge(...observables);\n}\n","import { Injector, OpaqueToken } from '@angular/core';\nimport { EffectsSubscription } from './effects-subscription';\n\n\nexport const /** @type {?} */ afterBootstrapEffects = new OpaqueToken('ngrx:effects: Bootstrap Effects');\n/**\n * @param {?} injector\n * @param {?} subscription\n * @return {?}\n */\nexport function runAfterBootstrapEffects(injector: Injector, subscription: EffectsSubscription) {\n  return () => {\n    const /** @type {?} */ effectInstances = injector.get(afterBootstrapEffects, false);\n\n    if (effectInstances) {\n      subscription.addEffects(effectInstances);\n    }\n  };\n}\n","import { Action } from '@ngrx/store';\n/**\n * @param {?} action\n * @return {?}\n */\nexport function toPayload(action: Action) {\n  return ( /** @type {?} */((<any>action))).payload;\n}\n","import { Injectable, Inject } from '@angular/core';\nimport { Action, ScannedActionsSubject } from '@ngrx/store';\nimport { Observable } from 'rxjs/Observable';\nimport { Operator } from 'rxjs/Operator';\nimport { filter } from 'rxjs/operator/filter';\nexport class Actions extends Observable<Action> {\n/**\n * @param {?} actionsSubject\n */\nconstructor( actionsSubject: Observable<Action>) {\n    super();\n    this.source = actionsSubject;\n  }\n/**\n * @param {?} operator\n * @return {?}\n */\nlift(operator: Operator<any, Action>): Observable<Action> {\n    const /** @type {?} */ observable = new Actions(this);\n    observable.operator = operator;\n    return observable;\n  }\n/**\n * @param {...?} keys\n * @return {?}\n */\nofType(...keys: string[]): Actions {\n    return filter.call(this, ({ type }: {type: string}) => {\n      const /** @type {?} */ len = keys.length;\n      if (len === 1) {\n        return type === keys[0];\n      } else {\n        for (let /** @type {?} */ i = 0; i < len; i++) {\n          if (keys[i] === type) {\n            return true;\n          }\n        }\n      }\n      return false;\n    });\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Observable, decorators: [{ type: Inject, args: [ScannedActionsSubject, ] }, ]},\n];\n}\n\nfunction Actions_tsickle_Closure_declarations() {\n/** @type {?} */\nActions.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nActions.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { Injectable } from '@angular/core';\nexport class SingletonEffectsService {\nprivate registeredEffects: string[] = [];\n/**\n * @param {?} effectInstances\n * @return {?}\n */\nremoveExistingAndRegisterNew (effectInstances: any[]): any[] {\n    return effectInstances.filter(instance => {\n      const /** @type {?} */ instanceAsString = instance.constructor.toString();\n      if (this.registeredEffects.indexOf(instanceAsString) === -1) {\n        this.registeredEffects.push(instanceAsString);\n        return true;\n      }\n      return false;\n    });\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction SingletonEffectsService_tsickle_Closure_declarations() {\n/** @type {?} */\nSingletonEffectsService.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nSingletonEffectsService.ctorParameters;\n/** @type {?} */\nSingletonEffectsService.prototype.registeredEffects;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { OpaqueToken, Inject, SkipSelf, Optional, Injectable, OnDestroy } from '@angular/core';\nimport { Action, Store } from '@ngrx/store';\nimport { Observer } from 'rxjs/Observer';\nimport { Subscription } from 'rxjs/Subscription';\nimport { merge } from 'rxjs/observable/merge';\nimport { mergeEffects } from './effects';\nimport { SingletonEffectsService } from './singleton-effects.service';\n\n\nexport const /** @type {?} */ effects = new OpaqueToken('ngrx/effects: Effects');\nexport class EffectsSubscription extends Subscription implements OnDestroy {\n/**\n * @param {?} store\n * @param {?} singletonEffectsService\n * @param {?=} parent\n * @param {?=} effectInstances\n */\nconstructor(\nprivate store: Observer<Action>,\nprivate singletonEffectsService: SingletonEffectsService,\npublic parent?: EffectsSubscription,\n      effectInstances?: any[]\n  ) {\n    super();\n\n    if (parent) {\n      parent.add(this);\n    }\n\n    if (typeof effectInstances !== 'undefined' && effectInstances) {\n      this.addEffects(effectInstances);\n    }\n  }\n/**\n * @param {?} effectInstances\n * @return {?}\n */\naddEffects(effectInstances: any[]) {\n    effectInstances = this.singletonEffectsService.removeExistingAndRegisterNew(effectInstances);\n\n    const /** @type {?} */ sources = effectInstances.map(mergeEffects);\n    const /** @type {?} */ merged = merge(...sources);\n\n    this.add(merged.subscribe(this.store));\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\n    if (!this.closed) {\n      this.unsubscribe();\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: undefined, decorators: [{ type: Inject, args: [Store, ] }, ]},\n{type: SingletonEffectsService, decorators: [{ type: Inject, args: [SingletonEffectsService, ] }, ]},\n{type: EffectsSubscription, decorators: [{ type: Optional }, { type: SkipSelf }, ]},\n{type: Array, decorators: [{ type: Optional }, { type: Inject, args: [effects, ] }, ]},\n];\n}\n\nfunction EffectsSubscription_tsickle_Closure_declarations() {\n/** @type {?} */\nEffectsSubscription.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nEffectsSubscription.ctorParameters;\n/** @type {?} */\nEffectsSubscription.prototype.store;\n/** @type {?} */\nEffectsSubscription.prototype.singletonEffectsService;\n/** @type {?} */\nEffectsSubscription.prototype.parent;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { NgModule, Injector, Type, APP_BOOTSTRAP_LISTENER, OpaqueToken } from '@angular/core';\nimport { Actions } from './actions';\nimport { EffectsSubscription, effects } from './effects-subscription';\nimport { runAfterBootstrapEffects, afterBootstrapEffects } from './bootstrap-listener';\nimport { SingletonEffectsService } from './singleton-effects.service';\nexport class EffectsModule {\n/**\n * @return {?}\n */\nstatic forRoot() {\n    return {\n      ngModule: EffectsModule,\n      providers: [\n        SingletonEffectsService\n      ]\n    };\n  }\n/**\n * @param {?} type\n * @return {?}\n */\nstatic run(type: Type<any>) {\n    return {\n      ngModule: EffectsModule,\n      providers: [\n        EffectsSubscription,\n        type,\n        { provide: effects, useExisting: type, multi: true }\n      ]\n    };\n  }\n/**\n * @param {?} type\n * @return {?}\n */\nstatic runAfterBootstrap(type: Type<any>) {\n    return {\n      ngModule: EffectsModule,\n      providers: [\n        type,\n        { provide: afterBootstrapEffects, useExisting: type, multi: true }\n      ]\n    };\n  }\n/**\n * @param {?} effectsSubscription\n */\nconstructor(private effectsSubscription: EffectsSubscription) {}\nstatic decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  providers: [\n    Actions,\n    EffectsSubscription,\n    {\n      provide: APP_BOOTSTRAP_LISTENER,\n      multi: true,\n      deps: [ Injector, EffectsSubscription ],\n      useFactory: runAfterBootstrapEffects\n    }\n  ]\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: EffectsSubscription, },\n];\n}\n\nfunction EffectsModule_tsickle_Closure_declarations() {\n/** @type {?} */\nEffectsModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nEffectsModule.ctorParameters;\n/** @type {?} */\nEffectsModule.prototype.effectsSubscription;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}