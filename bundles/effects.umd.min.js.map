{"version":3,"sources":["../../../modules/effects/src/effects_metadata.ts","../../../modules/effects/src/on_run_effects.ts","../../../modules/effects/src/effects_resolver.ts","../../../modules/effects/src/run_effects.ts","../../../modules/effects/src/effects_module.ts","../../../modules/effects/src/util.ts","../../../modules/effects/src/actions.ts","../../../modules/effects/src/tokens.ts","../../../modules/effects/src/error_reporter.ts","../../../modules/effects/src/effect_sources.ts","../../../modules/effects/src/effects_feature_module.ts","../../../modules/effects/src/effects_runner.ts"],"names":["getEffectMetadataEntries","sourceProto","r","hasOwnMetadata","METADATA_KEY","getOwnMetadata","setEffectMetadataEntries","entries","defineMetadata","Effect","_a","dispatch","target","propertyName","effects","metadata","concat","getSourceForInstance","instance","Object","getPrototypeOf","isOnRunEffects","sourceInstance","source","onRunEffectsKey","mergeEffects","sourceName","constructor","name","observables","getSourceMetadata","map","observable","ignoreElements","call","materialized$","materialize","notification","effect","merge","apply","resolveEffectSource","mergedEffects$","ngrxOnRunEffects","createRunEffects","effectSources","runner","rootEffects","start","forEach","effectSourceInstance","addEffects","createSourceInstances","instances","_i","arguments","length","toPayload","action","payload","Reflect","compose","Actions","_super","_this","this","__extends","prototype","lift","operator","ofType","allowedTypes","filter","some","type","Observable","decorators","Injectable","ctorParameters","Inject","args","ScannedActionsSubject","ROOT_EFFECTS","InjectionToken","FEATURE_EFFECTS","CONSOLE","ErrorReporter","console","report","reason","details","group","key","error","groupEnd","undefined","EffectSources","errorReporter","next","toActions","mergeMap","groupBy","source$","dematerialize","exhaustMap","output","kind","value","errorReason","Source","Dispatched","Notification","Error","Subject","EffectsFeatureModule","effectSourceGroups","NgModule","Array","EffectsRunner","store","effectsSubscription","subscribe","ngOnDestroy","unsubscribe","Store","RUN_EFFECTS","provide","APP_INITIALIZER","multi","deps","useFactory","EffectsModule","forFeature","featureEffects","ngModule","providers","forRoot","useValue"],"mappings":"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","file":"./dist/effects/bundles/effects.umd.min.js","sourcesContent":["import { merge } from 'rxjs/observable/merge';\nimport { ignoreElements } from 'rxjs/operator/ignoreElements';\nimport { Observable } from 'rxjs/Observable';\nimport { compose } from '@ngrx/store';\n\nconst /** @type {?} */ METADATA_KEY = '@ngrx/effects';\nconst /** @type {?} */ r: any = Reflect;\n\nexport interface EffectMetadata {\n  propertyName: string;\n  dispatch: boolean;\n}\n/**\n * @param {?} sourceProto\n * @return {?}\n */\nfunction getEffectMetadataEntries(sourceProto: any): EffectMetadata[] {\n  if (r.hasOwnMetadata(METADATA_KEY, sourceProto)) {\n    return r.getOwnMetadata(METADATA_KEY, sourceProto);\n  }\n\n  return [];\n}\n/**\n * @param {?} sourceProto\n * @param {?} entries\n * @return {?}\n */\nfunction setEffectMetadataEntries(sourceProto: any, entries: EffectMetadata[]) {\n  r.defineMetadata(METADATA_KEY, entries, sourceProto);\n}\n/**\n * @param {?=} __0\n * @return {?}\n */\nexport function Effect({ dispatch } = { dispatch: true }): PropertyDecorator {\n  return function(target: any, propertyName: string) {\n    const /** @type {?} */ effects: EffectMetadata[] = getEffectMetadataEntries(target);\n    const /** @type {?} */ metadata: EffectMetadata = { propertyName, dispatch };\n\n    setEffectMetadataEntries(target, [...effects, metadata]);\n  };\n}\n/**\n * @param {?} instance\n * @return {?}\n */\nexport function getSourceForInstance(instance: Object): any {\n  return Object.getPrototypeOf(instance);\n}\n\nexport const /** @type {?} */ getSourceMetadata = compose(\n  getEffectMetadataEntries,\n  getSourceForInstance,\n);\n","import { Observable } from 'rxjs/Observable';\nimport { getSourceForInstance } from './effects_metadata';\nimport { EffectNotification } from './effects_resolver';\n\nexport interface OnRunEffects {\n  ngrxOnRunEffects(\n    resolvedEffects$: Observable<EffectNotification>,\n  ): Observable<EffectNotification>;\n}\n\nconst /** @type {?} */ onRunEffectsKey: keyof OnRunEffects = 'ngrxOnRunEffects';\n/**\n * @param {?} sourceInstance\n * @return {?}\n */\nexport function isOnRunEffects(\n  sourceInstance: Object,\n): sourceInstance is OnRunEffects {\n  const /** @type {?} */ source = getSourceForInstance(sourceInstance);\n\n  return (\n    onRunEffectsKey in source && typeof source[onRunEffectsKey] === 'function'\n  );\n}\n","import { merge } from 'rxjs/observable/merge';\nimport { ignoreElements } from 'rxjs/operator/ignoreElements';\nimport { materialize } from 'rxjs/operator/materialize';\nimport { map } from 'rxjs/operator/map';\nimport { Observable } from 'rxjs/Observable';\nimport { Notification } from 'rxjs/Notification';\nimport { Action } from '@ngrx/store';\nimport { getSourceMetadata, getSourceForInstance } from './effects_metadata';\nimport { isOnRunEffects } from './on_run_effects';\n\nexport interface EffectNotification {\n  effect: Observable<any> | (() => Observable<any>);\n  propertyName: string;\n  sourceName: string;\n  sourceInstance: any;\n  notification: Notification<Action | null | undefined>;\n}\n/**\n * @param {?} sourceInstance\n * @return {?}\n */\nexport function mergeEffects(\n  sourceInstance: any,\n): Observable<EffectNotification> {\n  const /** @type {?} */ sourceName = getSourceForInstance(sourceInstance).constructor.name;\n\n  const /** @type {?} */ observables: Observable<any>[] = getSourceMetadata(\n    sourceInstance,\n  ).map(({ propertyName, dispatch }): Observable<EffectNotification> => {\n    const /** @type {?} */ observable: Observable<any> = typeof sourceInstance[propertyName] ===\n      'function'\n      ? sourceInstance[propertyName]()\n      : sourceInstance[propertyName];\n\n    if (dispatch === false) {\n      return ignoreElements.call(observable);\n    }\n\n    const /** @type {?} */ materialized$ = materialize.call(observable);\n\n    return map.call(\n      materialized$,\n      (notification: Notification<Action>): EffectNotification => ({\n        effect: sourceInstance[propertyName],\n        notification,\n        propertyName,\n        sourceName,\n        sourceInstance,\n      }),\n    );\n  });\n\n  return merge(...observables);\n}\n/**\n * @param {?} sourceInstance\n * @return {?}\n */\nexport function resolveEffectSource(sourceInstance: any) {\n  const /** @type {?} */ mergedEffects$ = mergeEffects(sourceInstance);\n\n  if (isOnRunEffects(sourceInstance)) {\n    return sourceInstance.ngrxOnRunEffects(mergedEffects$);\n  }\n\n  return mergedEffects$;\n}\n","import {\n  APP_INITIALIZER,\n  Provider,\n  Optional,\n  Type,\n  Injector,\n} from '@angular/core';\nimport { EffectsRunner } from './effects_runner';\nimport { EffectSources } from './effect_sources';\nimport { BOOTSTRAP_EFFECTS, ROOT_EFFECTS } from './tokens';\n/**\n * @param {?} effectSources\n * @param {?} runner\n * @param {?} rootEffects\n * @return {?}\n */\nexport function createRunEffects(\n  effectSources: EffectSources,\n  runner: EffectsRunner,\n  rootEffects: any[],\n) {\n  return function() {\n    runner.start();\n\n    rootEffects.forEach(effectSourceInstance =>\n      effectSources.addEffects(effectSourceInstance),\n    );\n  };\n}\n\nexport const /** @type {?} */ RUN_EFFECTS: Provider = {\n  provide: APP_INITIALIZER,\n  multi: true,\n  deps: [EffectSources, EffectsRunner, ROOT_EFFECTS],\n  useFactory: createRunEffects,\n};\n","import { NgModule, ModuleWithProviders, Type } from '@angular/core';\nimport { EffectSources } from './effect_sources';\nimport { Actions } from './actions';\nimport { ROOT_EFFECTS, FEATURE_EFFECTS, CONSOLE } from './tokens';\nimport { EffectsFeatureModule } from './effects_feature_module';\nimport { EffectsRunner } from './effects_runner';\nimport { ErrorReporter } from './error_reporter';\nimport { RUN_EFFECTS } from './run_effects';\nexport class EffectsModule {\n/**\n * @param {?} featureEffects\n * @return {?}\n */\nstatic forFeature(featureEffects: Type<any>[]): ModuleWithProviders {\n    return {\n      ngModule: EffectsFeatureModule,\n      providers: [\n        featureEffects,\n        {\n          provide: FEATURE_EFFECTS,\n          multi: true,\n          deps: featureEffects,\n          useFactory: createSourceInstances,\n        },\n      ],\n    };\n  }\n/**\n * @param {?} rootEffects\n * @return {?}\n */\nstatic forRoot(rootEffects: Type<any>[]): ModuleWithProviders {\n    return {\n      ngModule: EffectsModule,\n      providers: [\n        EffectsRunner,\n        EffectSources,\n        ErrorReporter,\n        Actions,\n        RUN_EFFECTS,\n        rootEffects,\n        {\n          provide: ROOT_EFFECTS,\n          deps: rootEffects,\n          useFactory: createSourceInstances,\n        },\n        {\n          provide: CONSOLE,\n          useValue: console,\n        },\n      ],\n    };\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction EffectsModule_tsickle_Closure_declarations() {\n/** @type {?} */\nEffectsModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nEffectsModule.ctorParameters;\n}\n\n/**\n * @param {...?} instances\n * @return {?}\n */\nexport function createSourceInstances(...instances: any[]) {\n  return instances;\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { Action } from '@ngrx/store';\n/**\n * @param {?} action\n * @return {?}\n */\nexport function toPayload(action: Action): any {\n  return ( /** @type {?} */((action as any))).payload;\n}\n","import { Injectable, Inject } from '@angular/core';\nimport { Action, ScannedActionsSubject } from '@ngrx/store';\nimport { Observable } from 'rxjs/Observable';\nimport { Operator } from 'rxjs/Operator';\nimport { filter } from 'rxjs/operator/filter';\nexport class Actions<V = Action> extends Observable<V> {\n/**\n * @param {?=} source\n */\nconstructor( source?: Observable<V>) {\n    super();\n\n    if (source) {\n      this.source = source;\n    }\n  }\n/**\n * @template R\n * @param {?} operator\n * @return {?}\n */\nlift<R>(operator: Operator<V, R>): Observable<R> {\n    const /** @type {?} */ observable = new Actions<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n/**\n * @param {...?} allowedTypes\n * @return {?}\n */\nofType(...allowedTypes: string[]): Actions {\n    return filter.call(this, (action: Action) =>\n      allowedTypes.some(type => type === action.type),\n    );\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Observable, decorators: [{ type: Inject, args: [ScannedActionsSubject, ] }, ]},\n];\n}\n\nfunction Actions_tsickle_Closure_declarations() {\n/** @type {?} */\nActions.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nActions.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { InjectionToken, Type } from '@angular/core';\n\nexport const /** @type {?} */ IMMEDIATE_EFFECTS = new InjectionToken<any[]>(\n  'ngrx/effects: Immediate Effects',\n);\nexport const /** @type {?} */ BOOTSTRAP_EFFECTS = new InjectionToken<any[]>(\n  'ngrx/effects: Bootstrap Effects',\n);\nexport const /** @type {?} */ ROOT_EFFECTS = new InjectionToken<Type<any>[]>(\n  'ngrx/effects: Root Effects',\n);\nexport const /** @type {?} */ FEATURE_EFFECTS = new InjectionToken<any[][]>(\n  'ngrx/effects: Feature Effects',\n);\nexport const /** @type {?} */ CONSOLE = new InjectionToken<Console>('Browser Console');\n","import { Injectable, InjectionToken, Inject } from '@angular/core';\nimport { CONSOLE } from './tokens';\nexport class ErrorReporter {\n/**\n * @param {?} console\n */\nconstructor(\nprivate console: any) {}\n/**\n * @param {?} reason\n * @param {?} details\n * @return {?}\n */\nreport(reason: string, details: any): void {\n    this.console.group(reason);\n\n    for (let /** @type {?} */ key in details) {\n      this.console.error(`${key}:`, details[key]);\n    }\n\n    this.console.groupEnd();\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: undefined, decorators: [{ type: Inject, args: [CONSOLE, ] }, ]},\n];\n}\n\nfunction ErrorReporter_tsickle_Closure_declarations() {\n/** @type {?} */\nErrorReporter.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nErrorReporter.ctorParameters;\n/** @type {?} */\nErrorReporter.prototype.console;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { groupBy, GroupedObservable } from 'rxjs/operator/groupBy';\nimport { mergeMap } from 'rxjs/operator/mergeMap';\nimport { exhaustMap } from 'rxjs/operator/exhaustMap';\nimport { map } from 'rxjs/operator/map';\nimport { dematerialize } from 'rxjs/operator/dematerialize';\nimport { Observable } from 'rxjs/Observable';\nimport { Subject } from 'rxjs/Subject';\nimport { Injectable, isDevMode } from '@angular/core';\nimport { Action } from '@ngrx/store';\nimport { getSourceForInstance } from './effects_metadata';\nimport { resolveEffectSource, EffectNotification } from './effects_resolver';\nimport { ErrorReporter } from './error_reporter';\nexport class EffectSources extends Subject<any> {\n/**\n * @param {?} errorReporter\n */\nconstructor(private errorReporter: ErrorReporter) {\n    super();\n  }\n/**\n * @param {?} effectSourceInstance\n * @return {?}\n */\naddEffects(effectSourceInstance: any) {\n    this.next(effectSourceInstance);\n  }\n/**\n * @return {?}\n */\ntoActions(): Observable<Action> {\n    return mergeMap.call(\n      groupBy.call(this, getSourceForInstance),\n      (source$: GroupedObservable<any, any>) =>\n        dematerialize.call(\n          map.call(\n            exhaustMap.call(source$, resolveEffectSource),\n            (output: EffectNotification) => {\n              switch (output.notification.kind) {\n                case 'N': {\n                  const /** @type {?} */ action = output.notification.value;\n                  const /** @type {?} */ isInvalidAction =\n                    !action || !action.type || typeof action.type !== 'string';\n\n                  if (isInvalidAction) {\n                    const /** @type {?} */ errorReason = `Effect \"${output.sourceName}.${output.propertyName}\" dispatched an invalid action`;\n\n                    this.errorReporter.report(errorReason, {\n                      Source: output.sourceInstance,\n                      Effect: output.effect,\n                      Dispatched: action,\n                      Notification: output.notification,\n                    });\n                  }\n\n                  break;\n                }\n                case 'E': {\n                  const /** @type {?} */ errorReason = `Effect \"${output.sourceName}.${output.propertyName}\" threw an error`;\n\n                  this.errorReporter.report(errorReason, {\n                    Source: output.sourceInstance,\n                    Effect: output.effect,\n                    Error: output.notification.error,\n                    Notification: output.notification,\n                  });\n\n                  break;\n                }\n              }\n\n              return output.notification;\n            },\n          ),\n        ),\n    );\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ErrorReporter, },\n];\n}\n\nfunction EffectSources_tsickle_Closure_declarations() {\n/** @type {?} */\nEffectSources.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nEffectSources.ctorParameters;\n/** @type {?} */\nEffectSources.prototype.errorReporter;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { NgModule, Inject, Type } from '@angular/core';\nimport { EffectSources } from './effect_sources';\nimport { FEATURE_EFFECTS } from './tokens';\nexport class EffectsFeatureModule {\n/**\n * @param {?} effectSources\n * @param {?} effectSourceGroups\n */\nconstructor(\nprivate effectSources: EffectSources,\n     effectSourceGroups: any[][],\n  ) {\n    effectSourceGroups.forEach(group =>\n      group.forEach(effectSourceInstance =>\n        effectSources.addEffects(effectSourceInstance),\n      ),\n    );\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: EffectSources, },\n{type: Array, decorators: [{ type: Inject, args: [FEATURE_EFFECTS, ] }, ]},\n];\n}\n\nfunction EffectsFeatureModule_tsickle_Closure_declarations() {\n/** @type {?} */\nEffectsFeatureModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nEffectsFeatureModule.ctorParameters;\n/** @type {?} */\nEffectsFeatureModule.prototype.effectSources;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { Subscription } from 'rxjs/Subscription';\nimport { Injectable, OnDestroy } from '@angular/core';\nimport { Store } from '@ngrx/store';\nimport { EffectSources } from './effect_sources';\nexport class EffectsRunner implements OnDestroy {\nprivate effectsSubscription: Subscription | null = null;\n/**\n * @param {?} effectSources\n * @param {?} store\n */\nconstructor(\nprivate effectSources: EffectSources,\nprivate store: Store<any>,\n  ) {}\n/**\n * @return {?}\n */\nstart() {\n    if (!this.effectsSubscription) {\n      this.effectsSubscription = this.effectSources\n        .toActions()\n        .subscribe(this.store);\n    }\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\n    if (this.effectsSubscription) {\n      this.effectsSubscription.unsubscribe();\n      this.effectsSubscription = null;\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: EffectSources, },\n{type: Store, },\n];\n}\n\nfunction EffectsRunner_tsickle_Closure_declarations() {\n/** @type {?} */\nEffectsRunner.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nEffectsRunner.ctorParameters;\n/** @type {?} */\nEffectsRunner.prototype.effectsSubscription;\n/** @type {?} */\nEffectsRunner.prototype.effectSources;\n/** @type {?} */\nEffectsRunner.prototype.store;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}