{"version":3,"sources":["../../../modules/effects/src/effects.ts","../../../modules/effects/src/bootstrap-listener.ts","../../../modules/effects/src/util.ts","../../../modules/effects/src/actions.ts","../../../modules/effects/src/effects-subscription.ts","../../../modules/effects/src/effects.module.ts"],"names":["Effect","_a","dispatch","target","propertyName","hasOwnMetadata","METADATA_KEY","defineMetadata","effects","getOwnMetadata","metadata","concat","getEffectsMetadata","instance","Object","getPrototypeOf","mergeEffects","observables","map","observable","ignoreElements","call","merge","apply","runAfterBootstrapEffects","injector","subscription","effectInstances","get","afterBootstrapEffects","addEffects","toPayload","action","payload","Actions","_super","actionsSubject","_this","this","source","__extends","prototype","lift","operator","ofType","keys","_i","arguments","length","filter","type","len","i","Observable","decorators","Injectable","ctorParameters","Inject","args","ScannedActionsSubject","OpaqueToken","EffectsSubscription","store","parent","add","sources","merged","subscribe","ngOnDestroy","closed","unsubscribe","Subscription","undefined","Store","Optional","SkipSelf","Array","EffectsModule","effectsSubscription","run","ngModule","providers","provide","useExisting","multi","runAfterBootstrap","NgModule","APP_BOOTSTRAP_LISTENER","deps","Injector","useFactory"],"mappings":"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","file":"./dist/effects/bundles/effects.umd.min.js","sourcesContent":["import { merge } from 'rxjs/observable/merge';\nimport { ignoreElements } from 'rxjs/operator/ignoreElements';\nimport { Store } from '@ngrx/store';\nimport { Observable } from 'rxjs/Observable';\n\nconst /** @type {?} */ METADATA_KEY = '@ngrx/effects';\n\nexport interface EffectMetadata {\n  propertyName: string;\n  dispatch: boolean;\n}\n/**\n * @param {?=} __0\n * @return {?}\n */\nexport function Effect({ dispatch } = { dispatch: true }): PropertyDecorator {\n  return function(target: any, propertyName: string) {\n    if (!( /** @type {?} */((Reflect as any))).hasOwnMetadata(METADATA_KEY, target)) {\n      ( /** @type {?} */((Reflect as any))).defineMetadata(METADATA_KEY, [], target);\n    }\n\n    const /** @type {?} */ effects: EffectMetadata[] = ( /** @type {?} */((Reflect as any))).getOwnMetadata(METADATA_KEY, target);\n    const /** @type {?} */ metadata: EffectMetadata = { propertyName, dispatch };\n\n    ( /** @type {?} */((Reflect as any))).defineMetadata(METADATA_KEY, [ ...effects, metadata ], target);\n  };\n}\n/**\n * @param {?} instance\n * @return {?}\n */\nexport function getEffectsMetadata(instance: any): EffectMetadata[] {\n  const /** @type {?} */ target = Object.getPrototypeOf(instance);\n\n  if (!( /** @type {?} */((Reflect as any))).hasOwnMetadata(METADATA_KEY, target)) {\n    return [];\n  }\n\n  return ( /** @type {?} */((Reflect as any))).getOwnMetadata(METADATA_KEY, target);\n}\n/**\n * @param {?} instance\n * @return {?}\n */\nexport function mergeEffects(instance: any): Observable<any> {\n  const /** @type {?} */ observables: Observable<any>[] = getEffectsMetadata(instance).map(\n    ({ propertyName, dispatch }): Observable<any> => {\n      const /** @type {?} */ observable = typeof instance[propertyName] === 'function' ?\n        instance[propertyName]() : instance[propertyName];\n\n      if (dispatch === false) {\n        return ignoreElements.call(observable);\n      }\n\n      return observable;\n    }\n  );\n\n  return merge(...observables);\n}\n","import { Injector, OpaqueToken } from '@angular/core';\nimport { EffectsSubscription } from './effects-subscription';\n\n\nexport const /** @type {?} */ afterBootstrapEffects = new OpaqueToken('ngrx:effects: Bootstrap Effects');\n/**\n * @param {?} injector\n * @param {?} subscription\n * @return {?}\n */\nexport function runAfterBootstrapEffects(injector: Injector, subscription: EffectsSubscription) {\n  return () => {\n    const /** @type {?} */ effectInstances = injector.get(afterBootstrapEffects, false);\n\n    if (effectInstances) {\n      subscription.addEffects(effectInstances);\n    }\n  };\n}\n","import { Action } from '@ngrx/store';\n/**\n * @param {?} action\n * @return {?}\n */\nexport function toPayload(action: Action) {\n  return ( /** @type {?} */((<any>action))).payload;\n}\n","import { Injectable, Inject } from '@angular/core';\nimport { Action, ScannedActionsSubject } from '@ngrx/store';\nimport { Observable } from 'rxjs/Observable';\nimport { Operator } from 'rxjs/Operator';\nimport { filter } from 'rxjs/operator/filter';\nexport class Actions extends Observable<Action> {\n/**\n * @param {?} actionsSubject\n */\nconstructor( actionsSubject: Observable<Action>) {\n    super();\n    this.source = actionsSubject;\n  }\n/**\n * @param {?} operator\n * @return {?}\n */\nlift(operator: Operator<any, Action>): Observable<Action> {\n    const /** @type {?} */ observable = new Actions(this);\n    observable.operator = operator;\n    return observable;\n  }\n/**\n * @param {...?} keys\n * @return {?}\n */\nofType(...keys: string[]): Actions {\n    return filter.call(this, ({ type }: {type: string}) => {\n      const /** @type {?} */ len = keys.length;\n      if (len === 1) {\n        return type === keys[0];\n      } else {\n        for (let /** @type {?} */ i = 0; i < len; i++) {\n          if (keys[i] === type) {\n            return true;\n          }\n        }\n      }\n      return false;\n    });\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Observable, decorators: [{ type: Inject, args: [ScannedActionsSubject, ] }, ]},\n];\n}\n\nfunction Actions_tsickle_Closure_declarations() {\n/** @type {?} */\nActions.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nActions.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { OpaqueToken, Inject, SkipSelf, Optional, Injectable, OnDestroy } from '@angular/core';\nimport { Action, Store } from '@ngrx/store';\nimport { Observer } from 'rxjs/Observer';\nimport { Subscription } from 'rxjs/Subscription';\nimport { merge } from 'rxjs/observable/merge';\nimport { mergeEffects } from './effects';\n\n\nexport const /** @type {?} */ effects = new OpaqueToken('ngrx/effects: Effects');\nexport class EffectsSubscription extends Subscription implements OnDestroy {\n/**\n * @param {?} store\n * @param {?=} parent\n * @param {?=} effectInstances\n */\nconstructor(\nprivate store: Observer<Action>,\npublic parent?: EffectsSubscription,\n      effectInstances?: any[]\n  ) {\n    super();\n\n    if (parent) {\n      parent.add(this);\n    }\n\n    if (typeof effectInstances !== 'undefined' && effectInstances) {\n      this.addEffects(effectInstances);\n    }\n  }\n/**\n * @param {?} effectInstances\n * @return {?}\n */\naddEffects(effectInstances: any[]) {\n    const /** @type {?} */ sources = effectInstances.map(mergeEffects);\n    const /** @type {?} */ merged = merge(...sources);\n\n    this.add(merged.subscribe(this.store));\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\n    if (!this.closed) {\n      this.unsubscribe();\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: undefined, decorators: [{ type: Inject, args: [Store, ] }, ]},\n{type: EffectsSubscription, decorators: [{ type: Optional }, { type: SkipSelf }, ]},\n{type: Array, decorators: [{ type: Optional }, { type: Inject, args: [effects, ] }, ]},\n];\n}\n\nfunction EffectsSubscription_tsickle_Closure_declarations() {\n/** @type {?} */\nEffectsSubscription.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nEffectsSubscription.ctorParameters;\n/** @type {?} */\nEffectsSubscription.prototype.store;\n/** @type {?} */\nEffectsSubscription.prototype.parent;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { NgModule, Injector, Type, APP_BOOTSTRAP_LISTENER, OpaqueToken } from '@angular/core';\nimport { Actions } from './actions';\nimport { EffectsSubscription, effects } from './effects-subscription';\nimport { runAfterBootstrapEffects, afterBootstrapEffects } from './bootstrap-listener';\nexport class EffectsModule {\n/**\n * @param {?} type\n * @return {?}\n */\nstatic run(type: Type<any>) {\n    return {\n      ngModule: EffectsModule,\n      providers: [\n        EffectsSubscription,\n        type,\n        { provide: effects, useExisting: type, multi: true }\n      ]\n    };\n  }\n/**\n * @param {?} type\n * @return {?}\n */\nstatic runAfterBootstrap(type: Type<any>) {\n    return {\n      ngModule: EffectsModule,\n      providers: [\n        type,\n        { provide: afterBootstrapEffects, useExisting: type, multi: true }\n      ]\n    };\n  }\n/**\n * @param {?} effectsSubscription\n */\nconstructor(private effectsSubscription: EffectsSubscription) {}\nstatic decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  providers: [\n    Actions,\n    EffectsSubscription,\n    {\n      provide: APP_BOOTSTRAP_LISTENER,\n      multi: true,\n      deps: [ Injector, EffectsSubscription ],\n      useFactory: runAfterBootstrapEffects\n    }\n  ]\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: EffectsSubscription, },\n];\n}\n\nfunction EffectsModule_tsickle_Closure_declarations() {\n/** @type {?} */\nEffectsModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nEffectsModule.ctorParameters;\n/** @type {?} */\nEffectsModule.prototype.effectsSubscription;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}